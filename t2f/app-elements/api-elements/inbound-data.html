<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/etools-ajax/etools-ajax.html">
<link rel="import" href="../../app-config/etools-app-config.html">


<dom-module id="et2f-inbound-data">
  <template>

    <etools-ajax url="[[travelUrl]]"
      on-success="_handleData" loading="{{loading}}"></etools-ajax>

    <iron-ajax id="ghostAjax" loading="{{loading}}"></iron-ajax>


  </template>

  <script>
    Polymer({

      is: 'et2f-inbound-data',

      properties: {
        et2fData: {
          type: Object,
          notify: true,
        },
        structure: {
          type: Object,
          notify: true,
        },
        travelId: {
          type: String
        },
        travelUrl: {
          type: String,
          computed: '_computeUrl(travelId)',
        },
        dataToSerialize: {
          type: Object,
          observer: '_handleIncomingData'
        },
        loading: {
          type: Boolean,
          notify: true
        },
        listen: {
          type: Boolean,
          value: true
        },
        route: {
          type: Object,
          notify: true
        }
      },
      behaviors: [et2fBehaviors.ApiBehavior],
      _computeUrl: function(travelId) {
        if (this.listen && travelId && travelId !== -1) {
          return etoolsAppConfig.globals.computeTemplate('et2fTravelDetail', {
            id: travelId
          }).url;
        }
      },

      _handleIncomingData: function(incomingData) {
        this.listen = false;
        var id = incomingData.id;
        this._handleData(null, incomingData);
        var route = this.route;
        var routeFragments = route.path.split('/');
        route.path = (routeFragments.slice(0, routeFragments.length - 1).join('/')) + '/' + id;
        this.set('route', {});
        this.set('route', route);
        this.listen = true;
      },

      _getParameterByName: function(name, url) {
        if (!url) {
          url = window.location.href;
        }
        name = name.replace(/[\[\]]/g, '\\$&');
        var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
        var results = regex.exec(url);
        if (!results) {
          return null;
        }
        if (!results[2]) {
          return '';
        }
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
      },

      _handleData: function(e, incomingData) {
        var self = this;
        var ghosts = [];
        // not clear why this function call return an object in
        // the form type - value instead of the object with the value
        var lib = self._structureLib().value;
        var statusLib = {
          'planned': 'Planned',
          'submitted': 'Submitted',
          'approved': 'Approved',
          'rejected': 'Rejected',
          'sent_for_payment': 'Sent for payment',
          'cancelled': 'Cancelled',
          'done': 'Certification needed',
          'certification_approved': 'Certification approved',
          'certification_rejected': 'Certification rejected',
          'certification_submitted': 'Certification submitted',
          'certified': 'Certified',
          'completed': 'Completed'
        };

        var nonBaseKeys = [
          'deductions',
          'itinerary',
          'activities',
          'cost_assignments',
          'expenses',
          'clearances',
          'rejection_note',
          'cert_rejection_note',
          'cancellation_note',
          'certification_note',
          'misc_expenses',
          'canceled_at',
          'completed_at',
          'cancellation_date',
          'completion_date',
          'attachments',
          'cost_summary',
          'report',
          'action_points'
        ];

        var dataKeys = Object.keys(incomingData).filter(function(key) {
          return nonBaseKeys.indexOf(key) === -1;
        });

        incomingData.baseDetails = {};
        dataKeys.forEach(function(key) {
          incomingData.baseDetails[key] = incomingData[key];
          delete incomingData[key];
        });

        function processGhostData(value, key, label) {
          if (!value) {
            return;
          }
          if (value instanceof Array) {
            value.forEach(function(item) {
              if (item.ghost) {
               ghosts.push({item: item, key: key, label: label});
              }
            });
          }
          if (value.ghost) {
            ghosts.push({item: value, key: key, label: label});
          }
          return value;
        }

        function handleObject(fieldSet, key) {
          // loop on the object inner keys
          if (!fieldSet) {
            return;
          }
          var localKeys = Object.keys(fieldSet);
          localKeys.forEach(function(label) {
            // search the structure library for a match

            var structureData = lib[key][label];
            if (structureData) {
              var result  = self._processLib(structureData, fieldSet[label], fieldSet);
              fieldSet[label] = processGhostData(result, key, label);
            }
          });
        }

        function handleArray(fieldSet, key) {
          if (fieldSet.length === 0 && key !== 'attachments') {
            // add one empty object in case of empty array
            fieldSet.push({});
          } else {
            //loop on array elements and run the object handling function
            fieldSet.forEach(function(innerFieldSet) {
              handleObject(innerFieldSet, key);
            });
          }
        }
        var newKeys = Object.keys(incomingData);
        newKeys.forEach(function(fieldSet) {
          if (incomingData[fieldSet] instanceof Array) {
            handleArray(incomingData[fieldSet], fieldSet);
          } else if (typeof incomingData[fieldSet] === 'object') {
            handleObject(incomingData[fieldSet], fieldSet);
          }
        });

        if (incomingData.baseDetails.status) {
          incomingData.status = statusLib[incomingData.baseDetails.status];
        } else {
          incomingData.status = statusLib.planned;
        }

        var ghostUrlLib = {
            baseDetails: {
              currency: {
                url: '/api/currencies/',
                category: 'currencies'
              },
            },
            itinerary: {
               airlines: {
                url: '/api/static_data/',
                category: 'airlines'
              },
              dsa_region: {
                url: '/api/dsa_regions/',
                category: 'dsa_regions'
              },
            },
            expenses: {
              type: {
                url: '/api/expense_types/',
                category: 'expense_types'
              },
               document_currency: {
                url: '/api/currencies/',
                category: 'currencies'
              },
            },
            cost_assignments: {
              fund: {
                url: '/api/wbs_grants_funds/',
                category: 'funds'
              },
              wbs: {
                url: '/api/wbs_grants_funds/',
                category: 'wbs'
              },
              grant: {
                url: '/api/wbs_grants_funds/',
                category: 'grants'
              }
            }
        };

        function parseAndFillStructureWithGhost(value, cat) {
          var structure = self.structure;
          // the parsing function expects an object filled with arrays, so  we build one
          var toParse = {};
          toParse[cat] = [value];
          var parsed = self._parseStructureData(toParse);
          console.log(parsed);
          structure[cat].push(parsed[cat]);

          // we extract the parsed object from the container array ensuring that is
          // parsed with the same logic as the rest of the structure
          parsed = parsed[cat].pop();
          self.push('structure.' + cat, parsed);
          return parsed;
        }

        var processed = 0;
        var toProcess = 0;
        function postCallOperation() {
            processed += 1;
            if (processed === toProcess) {
              processed = 0;
              toProcess = 0;
              self.set('et2fData', {});
              self.set('et2fData', incomingData);
              }
        }

        if (ghosts.length > 0) {
          // grab the reference to iron-ajax;
          var ajax = self.$.ghostAjax;

          ajax.addEventListener('response', function(e) {
              // using the url with the extra query string to get what ghost data are we processing
              var url = e.detail.xhr.responseURL;
              var response = e.detail.response;
              var cat = self._getParameterByName('category', url);
              var ghostIndex = self._getParameterByName('ghostIndex', url);
              var parsed = parseAndFillStructureWithGhost(response, cat);
              var currentGhost = ghosts[ghostIndex];

              // merge parsed data and ghost dummy object, keeping the reference.
              Object.assign(currentGhost.item, parsed);
              postCallOperation();
            });

          ajax.addEventListener('error', function() {
              postCallOperation();
          });

          ghosts.forEach(function(ghost, index) {
            console.log(ghost)
            var libValue = ghostUrlLib[ghost.key][ghost.label];
            if (libValue) {
              toProcess += 1;
              ajax.url = libValue.url
              + 'missing/?value=' + ghost.item.value
              + '&category=' + libValue.category
              + '&ghostIndex=' + index;

              ajax.generateRequest();
            }
          });

          if (toProcess === processed) {
              this.set('et2fData', {});
              this.set('et2fData', incomingData);
          }

        } else {
          this.set('et2fData', {});
          this.set('et2fData', incomingData);
        }
      }
    });
  </script>
</dom-module>
